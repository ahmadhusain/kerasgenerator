---
title: "Data Generator for Time Series Models"
author: "R. Dimas Bagas Herlambang"
date: "Last updated on: `r format(Sys.Date(), '%B %e, %Y')`"
bibliography: timeseries.bib
csl: apa.csl
link-citations: yes
output:
  rmarkdown::html_vignette:
    fig_caption: yes
vignette: >
  %\VignetteIndexEntry{Data Generator for Time Series Model}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}

# chunk opts
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  fig.align = "center",
  out.width = "85%"
)

```

Preparing a proper dataset for a supervised time series model sometimes could become very complex and tedious. There are some tutorials that already cover this kind of task: check out the tutorial made by [Dancho and Keydana](https://blogs.rstudio.com/tensorflow/posts/2018-06-25-sunspots-lstm/) [-@dancho2018predicting] for basic univariate model fitting without using data generator, and the one made by [Chollet and Allaire](https://blogs.rstudio.com/tensorflow/posts/2017-12-20-time-series-forecasting-with-recurrent-neural-networks/) [-@chollet2017time] for the multivariate model with a custom data generator. However, as you could see from the articles, there are no general framework on how to properly do the data preparation process.

In this article we will show you how `kerasgenerator` could help us in preparing a data generator for supervised time series [`keras`](https://keras.rstudio.com) models.

# Understanding the Time Series Array Shape {#introduction}

To fit a supervised time series model, many of `keras`' functions expect the target and feature data to be in an `array` object with a specific number of dimension. The input and output `array` need to have at least three dimension that representing:

1. Observation index
2. Number of timesteps
3. Number of distinct feature / target

You can imagine the `array` shape to be like this:

<!-- insert image -->

To understand better what each dimensions representing, let's follow a quick example using the popular [Sunspots](http://www.sidc.be/silso/datafiles) dataset [@sidc]. We will use the monthly total mean version:

```{r}

# import libs
library(tidyverse)

# import dataset
sunspot_tbl <- read_delim(
  file = "data/SN_m_tot_V2.0.csv",
  delim = ";",
  col_names = FALSE
)

# quick check
glimpse(sunspot_tbl)

```

The dataset is in a general time series format--it contains a time identifier column, each row representing a timestep, and it is regularly ordered. Before we move further, let's do a quick data preprocess:

```{r}

# import libs
library(lubridate)
library(magrittr)

# data preprocess
sunspot_tbl %<>%

  # select and rename relevant variables
  select(year = X1, month = X2, sunspot = X4) %>%

  # some data manipulation
  mutate(
    date = paste(year, month, "01", sep = "-") %>% ymd(),
    sunspot = str_squish(sunspot) %>% as.numeric()
  ) %>%

  # keep only relevant variables
  select(date, sunspot)

# quick check
glimpse(sunspot_tbl)

```

In supervised time series model, we need to define two important parameters for our datasets. The first parameter is the **lookback period**. The lookback period is determining **how many period behind should the targets look-up for its signal**, but it should be noted that **the periods in-between will be skipped**. The second parameter is the **timestep length**. This parameter define **the length of an observation of features** that would be considered as a sequence of signal for the target. **Note** that the terms that I just mentioned might be differ from other source, but I really suggest you to read the original paper of [Long Short-Term Memory](https://www.bioinf.jku.at/publications/older/2604.pdf) layer [@hochreiter1997long] and other valid sources to reach a better understanding of the terminologies.

Now let's make some illustration using our dataset to make it clear. Supposed that we want to predict the value of current mean total sunspots using the value from the same month in the previous year, but we also want to consider the yearly seasonality--hence, a 12-months sequence. Say, we pick the last observation of our dataset--the mean total sunspots in December 2018--as our target, then the target and features will be:

```{r}

# set some parameters
lookback <- 12
timesteps <- 12

# specify the target and feature
target <- tail(sunspot_tbl$date, 1)
feature_end <- target - months(lookback)
feature_start <- feature_end - months(timesteps) + months(1)

```

Notice that I set the `feature_start` to be `feature_end - months(timesteps) + months(1)`. This is because the `timesteps` value is representing how long is our feature--without `+ 1`, the timesteps would be 13. See the following figure for an illustration:

```{r, echo=FALSE, fig.cap="Supervised time series model illustration"}

# import libs
library(tidyquant)

# illustration
sunspot_tbl %>%
  tail(30) %>%
  mutate(
    label = case_when(
      date == target ~ "Target",
      date < target & date > feature_end ~ "Skipped",
      date <= feature_end & date >= feature_start ~ "Feature",
      TRUE ~ "Excluded"
    )
  ) %>%
  ggplot(aes(x = date, y = sunspot)) +
    geom_line() +
    geom_point(aes(colour = label)) +
    annotate(
      geom = "text",
      x = target,
      y = 18.5,
      label = "Target",
      colour = "darkred",
      angle = 90
    ) +
    annotate(
      geom = "segment",
      x = target,
      xend = target,
      y = 15,
      yend = 7.5,
      colour = "darkred",
      arrow = arrow()
    ) +
    annotate(
      geom = "text",
      x = target,
      y = 20,
      label = "Lookback to",
      colour = "darkgreen",
      hjust = 1.25
    ) +
    annotate(
      geom = "segment",
      x = target - months(1),
      xend = feature_end + days(15),
      y = 17.5,
      yend = 17.5,
      colour = "darkgreen",
      arrow = arrow()
    ) +
    annotate(
      geom = "text",
      x = feature_start + floor((feature_end - feature_start) / 2),
      y = 49,
      label = "Feature with 12 timesteps",
      colour = "darkblue"
    ) +
    annotate(
      geom = "rect",
      xmin = feature_start,
      xmax = feature_end,
      ymin = -Inf,
      ymax = Inf,
      alpha = 0.1,
      fill = "darkblue"
    ) +
    labs(x = NULL, y = NULL) +
    theme_tq() +
    theme(
      legend.position = c(0.9, 0.825),
      legend.direction = "vertical",
      legend.title = element_blank(),
      legend.background = element_rect(
        fill = "white",
        color = "black",
        size = 0.25,
        linetype = "solid"
      )
    ) +
    scale_colour_manual(
      values = c(
        "Excluded" = "black",
        "Feature" = "darkblue",
        "Skipped" = "darkgreen",
        "Target" = "darkred"
      ),
      breaks = c(
        "Excluded",
        "Feature",
        "Skipped",
        "Target"
      )
    )

```

If we follow this format, then we could convert the data into `array` matrices like this:

```{r}

# container arrays
x_array <- array(0, dim = c(1, timesteps, 1))
y_array <- array(0, dim = c(1, 1, 1))

# specify the row indices
y_row <- nrow(sunspot_tbl)
x_row <- y_row - lookback

# adjust the x indices according to the timesteps
x_indices <- seq(
  from = x_row - timesteps + 1,
  to = x_row
)

# convert the table into matrix
sunspot_matrix <- data.matrix(sunspot_tbl)

# fill the arrays
x_array[1, , ] <- sunspot_matrix[x_indices, 2]
y_array[1, , ] <- sunspot_matrix[y_row, 2]

```

Let's confirm the content inside the arrays:

```{r}

# check the structure
str(x_array)
str(y_array)

# check the data
x_array[1, , ]
y_array[1, , ]

```

Basically, the [`series_generator()`](/reference/series_generator) function is transforming your data into the format similar to above explanation; [`forecast_generator()`]((/reference/forecast_generator)) also works in a similar way, but disregards any attributes related to `y` (see [forecasting section](#forecast) for further explanation). Let's take a look on how those functions in action in the following sections.

# Fitting a Time Series Model using Data Generator {#fitting}

# Forecasting using Data Generator {#forecast}

# References {#reference}
